# パーティションテーブルの統計

https://www.cybertec-postgresql.com/en/partitioned-table-statistics/

- DB 作成

```
Users/masami » createdb -U postgres sample
Users/masami » psql -U postgres -d postgres
psql (17.0 (Ubuntu 17.0-1.pgdg24.04+1))
Type "help" for help.
```

- パーティションテーブル作成(パフォーマンス向上のためログなしテーブルを使用)

```sql
postgres=# CREATE TABLE tab (
   pk integer NOT NULL
) PARTITION BY LIST ((pk % 2));

CREATE UNLOGGED TABLE tab_even
PARTITION OF tab FOR VALUES IN (0);

CREATE UNLOGGED TABLE tab_odd
PARTITION OF tab FOR VALUES IN (1);
CREATE TABLE
CREATE TABLE
CREATE TABLE
```

- データ登録

```sql
postgres=# INSERT INTO tab
SELECT * FROM generate_series(1, 1000000);
INSERT 0 1000000
```

統計情報の取得

```sql
postgres=# \x
Expanded display is on.
postgres=# SELECT *
FROM pg_stats
WHERE tablename = 'tab_even'
  AND attname = 'pk';
-[ RECORD 1 ]----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
schemaname             | public
tablename              | tab_even
attname                | pk
inherited              | f
null_frac              | 0
avg_width              | 4
n_distinct             | -1
most_common_vals       |
most_common_freqs      |
histogram_bounds       | {98,9750,19636,29846,39124,49764,59304,69740,80104,91278,100482,110208,118612,128544,137826,147870,158910,168472,177374,186846,197116,207744,218368,227926,237994,247310,257406,267784,277310,286844,296964,307172,316540,326392,336696,347342,356904,366816,376448,386584,396840,406454,416208,426354,436762,446704,456768,467238,478482,488634,498886,509120,520190,529554,539120,549388,560228,570906,580672,590222,600556,611930,621734,631662,642606,653440,663958,674556,684096,694056,703978,713768,723456,732824,742976,753154,761694,770572,780548,790542,799962,810696,819832,830868,841724,851554,861200,871468,881256,890736,899764,910126,920764,931382,941784,950968,959704,970084,979526,989302,999952}
correlation            | 1
most_common_elems      |
most_common_elem_freqs |
elem_count_histogram   |
range_length_histogram |
range_empty_frac       |
range_bounds_histogram |


postgres=# SELECT *
FROM pg_stats
WHERE tablename = 'tab'
  AND attname = 'pk';
(0 rows)
```

PostgreSQL にはパーティションの統計情報はありますが、パーティションテーブルの統計情報はありません。

パーティションテーブルはタプルを直接格納しないため、自動バキュームでは処理されません。

パーティションテーブルの統計情報を参照するクエリで最適でないプランが生成される可能性があります。この問題を回避するには、ANALYZE パーティションテーブルに最初にデータが投入されたとき、そしてパーティション内のデータ分布が大幅に変更されたときに、手動で自動バキュームを実行してください。

パーティション化されたテーブルでは統計情報が自動的に取得されないことがわかります。問題は、これらの統計情報がどれほど重要かということです。結局のところ、パーティション化されたテーブルにはデータは含まれておらず、パーティションの統計情報も取得できます。多くの SQL 文では、これで十分です。以下に例を示します。

```sql
postgres=# EXPLAIN (ANALYZE) SELECT * FROM tab WHERE pk < 1000;
-[ RECORD 1 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Gather  (cost=1000.00..12874.19 rows=933 width=4) (actual time=2.746..78.019 rows=999 loops=1)
-[ RECORD 2 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   Workers Planned: 2
-[ RECORD 3 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   Workers Launched: 2
-[ RECORD 4 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   ->  Parallel Append  (cost=0.00..11780.89 rows=389 width=4) (actual time=15.992..55.224 rows=333 loops=3)
-[ RECORD 5 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         ->  Parallel Seq Scan on tab_even tab_1  (cost=0.00..5889.47 rows=275 width=4) (actual time=10.726..26.846 rows=166 loops=3)
-[ RECORD 6 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |               Filter: (pk < 1000)
-[ RECORD 7 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |               Rows Removed by Filter: 166500
-[ RECORD 8 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         ->  Parallel Seq Scan on tab_odd tab_2  (cost=0.00..5889.47 rows=274 width=4) (actual time=16.044..42.495 rows=250 loops=2)
-[ RECORD 9 ]------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |               Filter: (pk < 1000)
-[ RECORD 10 ]-----------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |               Rows Removed by Filter: 249750
-[ RECORD 11 ]-----------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Planning Time: 1.355 ms
-[ RECORD 12 ]-----------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Execution Time: 78.225 ms
```

推定値はかなり正確です。

ただし、PostgreSQL はパーティションテーブルの統計情報を使用して結合の結果行数を推定します。次の例をご覧ください。

```sql

postgres=# EXPLAIN (ANALYZE)
SELECT *
FROM generate_series(1, 100) AS gs(id)
  JOIN tab ON gs.id = tab.pk;
-[ RECORD 1 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Hash Join  (cost=2.25..28178.25 rows=500000 width=8) (actual time=0.127..224.806 rows=100 loops=1)
-[ RECORD 2 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   Hash Cond: (tab.pk = gs.id)
-[ RECORD 3 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   ->  Append  (cost=0.00..19426.00 rows=1000000 width=4) (actual time=0.015..142.281 rows=1000000 loops=1)
-[ RECORD 4 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         ->  Seq Scan on tab_even tab_1  (cost=0.00..7213.00 rows=500000 width=4) (actual time=0.015..35.641 rows=500000 loops=1)
-[ RECORD 5 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         ->  Seq Scan on tab_odd tab_2  (cost=0.00..7213.00 rows=500000 width=4) (actual time=0.015..33.962 rows=500000 loops=1)
-[ RECORD 6 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   ->  Hash  (cost=1.00..1.00 rows=100 width=4) (actual time=0.098..0.099 rows=100 loops=1)
-[ RECORD 7 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         Buckets: 1024  Batches: 1  Memory Usage: 12kB
-[ RECORD 8 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         ->  Function Scan on generate_series gs  (cost=0.00..1.00 rows=100 width=4) (actual time=0.074..0.080 rows=100 loops=1)
-[ RECORD 9 ]--------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Planning Time: 0.746 ms
-[ RECORD 10 ]-------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Execution Time: 224.947 ms
```

行数の推定値はすべて正確です。ただし、ハッシュ結合の推定値は 5000 倍もずれています。ANALYZE パーティション分割されたテーブルで推定値が改善されるかどうか確認してみましょう。

```sql
postgres=# ANALYZE tab;

EXPLAIN (ANALYZE)
SELECT *
FROM generate_series(1, 100) AS gs(id)
  JOIN tab ON gs.id = tab.pk;
ANALYZE
-[ RECORD 1 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Gather  (cost=1002.25..14966.87 rows=100 width=8) (actual time=0.643..176.753 rows=100 loops=1)
-[ RECORD 2 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   Workers Planned: 2
-[ RECORD 3 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   Workers Launched: 2
-[ RECORD 4 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |   ->  Hash Join  (cost=2.25..13956.87 rows=42 width=8) (actual time=44.157..145.342 rows=33 loops=3)
-[ RECORD 5 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         Hash Cond: (tab.pk = gs.id)
-[ RECORD 6 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         ->  Parallel Append  (cost=0.00..12391.69 rows=416668 width=4) (actual time=0.020..88.920 rows=333333 loops=3)
-[ RECORD 7 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |               ->  Parallel Seq Scan on tab_even tab_1  (cost=0.00..5154.18 rows=294118 width=4) (actual time=0.006..20.113 rows=166667 loops=3)
-[ RECORD 8 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |               ->  Parallel Seq Scan on tab_odd tab_2  (cost=0.00..5154.18 rows=294118 width=4) (actual time=0.022..39.359 rows=250000 loops=2)
-[ RECORD 9 ]-----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |         ->  Hash  (cost=1.00..1.00 rows=100 width=4) (actual time=0.078..0.079 rows=100 loops=3)
-[ RECORD 10 ]----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |               Buckets: 1024  Batches: 1  Memory Usage: 12kB
-[ RECORD 11 ]----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN |               ->  Function Scan on generate_series gs  (cost=0.00..1.00 rows=100 width=4) (actual time=0.037..0.049 rows=100 loops=3)
-[ RECORD 12 ]----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Planning Time: 0.576 ms
-[ RECORD 13 ]----------------------------------------------------------------------------------------------------------------------------------------------
QUERY PLAN | Execution Time: 176.836 ms
```

うまくいきました！これで pg_stats のデータも見ることができます。

```sql
postgres=# SELECT *
FROM pg_stats
WHERE tablename = 'tab'
  AND attname = 'pk';

-[ RECORD 1 ]----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
schemaname             | public
tablename              | tab
attname                | pk
inherited              | t
null_frac              | 0
avg_width              | 4
n_distinct             | -1
most_common_vals       |
most_common_freqs      |
histogram_bounds       | {1,10056,20455,30277,39858,51142,61160,70713,80090,90029,100583,110684,119469,129419,139108,149634,159293,169008,178927,189065,199241,210190,220224,230517,241058,250837,261094,270963,280793,291488,301939,311603,321854,331939,340521,350691,360608,369486,379244,389913,400147,409792,419414,429203,439007,448591,458408,468520,478851,489379,499406,509893,519913,529764,539192,549024,559126,568871,578936,589315,599826,609978,619833,630822,639985,650300,660527,670244,679817,689346,699418,708923,719087,728294,738232,747564,756763,765615,774980,786110,795250,805767,816163,826183,836774,847358,858178,868043,878531,888671,898354,908852,918999,928632,939038,948531,959131,968964,979679,989781,999956}
correlation            | 0.49748543
most_common_elems      |
most_common_elem_freqs |
elem_count_histogram   |
range_length_histogram |
range_empty_frac       |
range_bounds_histogram |
```

パーティションテーブルの統計情報を収集する必要があることは明らかです。少なくとも特定のクエリについてはそうです。しかし、自動バキュームではこの作業は完了しません。そのため、パーティションテーブルに対して明示的に実行をスケジュールする必要があります。
