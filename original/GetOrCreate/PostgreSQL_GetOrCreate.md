# How to Get or Create in PostgreSQL

下記のブログのトレースをします
https://hakibenita.com/postgresql-get-or-create

「取得または作成」は、データベース内のデータを同期するための非常に一般的な操作ですが、これを正しく実装するのは予想以上に難しい場合があります。

### 準備

DB 作成

```
createdb -U postgres sample
psql -U postgres -d sample
```

### 「取得または作成」の実装

ユーザーがアイテムにタグを付けることができるシステムがあるとします。
丁度、Qiita の記事のようなイメージです。

```sql
sample=# CREATE TABLE tags (
sample(#   id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
sample(#   name VARCHAR(50) NOT NULL
sample(# );
CREATE TABLE
sample=# ALTER TABLE tags ADD CONSTRAINT tags_name_unique UNIQUE(name);
ALTER TABLE
```

タグの追加は`INSERT`で簡単に実現きます

```Sql
sample=# INSERT INTO tags (name) VALUES ('A'), ('B') RETURNING *;
 id | name
----+------
  1 | A
  2 | B
(2 行)
```

すでに存在する名前のタグを追加しようとすると、エラーが発生します。

```sql
sample=# INSERT INTO tags ( name ) VALUES ( 'B' ) RETURNING * ;
ERROR:  重複したキー値は一意性制約"tags_name_unique"違反となります
DETAIL:  キー (name)=(B) はすでに存在します。
```

### べき等性の提供

`INSERT`はべき等ではないので、べき等になる関数を用意します

```Sql
sample=# CREATE OR REPLACE FUNCTION get_or_create_tag(tag_name tags.name%TYPE)
sample-# RETURNS SETOF tags AS $$
sample$# DECLARE
sample$#   tag_to_return tags%ROWTYPE;
sample$# BEGIN
sample$#   SELECT * INTO tag_to_return FROM tags WHERE name = tag_name;
sample$#   IF FOUND THEN
sample$#     RETURN NEXT tag_to_return;
sample$#   ELSE
sample$#     RETURN QUERY INSERT INTO tags (name) VALUES (tag_name) RETURNING *;
sample$#   END IF;
sample$# END;
sample$# $$ LANGUAGE plpgsql;
NOTICE:  型参照tags.name%TYPEはcharacter varyingに変換されました
CREATE FUNCTION
```

本関数を使うことで毎回同じ結果が返ります

```Sql
sample=#  TABLE tags;
 id | name
----+------
  1 | A
  2 | B
(2 行)


sample=# SELECT * FROM get_or_create_tag('C');
 id | name
----+------
  3 | C
(1 行)


sample=# SELECT * FROM get_or_create_tag('C');
 id | name
----+------
  3 | C
(1 行)

sample=# SELECT tags.*
sample-# FROM
sample-#   (VALUES ('B'), ('C'), ('D')) AS new(tag),
sample-#   get_or_create_tag(tag) AS tags;
 id | name
----+------
  2 | B
  3 | C
  4 | D
(3 行)
```

### 潜在的なレースへの対応

べき等性を担保する関数ですが、複数コネクションがある場合、
`INSERT`が競合する可能性があります。

`INSERT`に失敗したら、`SELECT`することで並列に実行されても結果が得られるようになります。

```sql
sample=# CREATE OR REPLACE FUNCTION get_or_create_tag(tag_name tags.name%TYPE)
sample-# RETURNS SETOF tags AS $$
sample$# DECLARE
sample$#   tag_to_return tags%ROWTYPE;
sample$# BEGIN
sample$#   SELECT * INTO tag_to_return FROM tags WHERE name = tag_name;
sample$#   IF FOUND THEN
sample$#     RETURN NEXT tag_to_return;
sample$#   ELSE
sample$#     BEGIN
sample$#       RETURN QUERY INSERT INTO tags (name) VALUES (tag_name) RETURNING *;
sample$#     EXCEPTION WHEN unique_violation THEN
sample$#       RETURN QUERY SELECT * FROM tags WHERE name = tag_name;
sample$#     END;
sample$#   END IF;
sample$# END;
sample$# $$ LANGUAGE plpgsql;
NOTICE:  型参照tags.name%TYPEはcharacter varyingに変換されました
CREATE FUNCTION
```

### UNIQUE 制約の利用

ほとんどのタグが初出の場合、`INSERT`の前の事前存在チェックは多くの場合無駄になります。

```Sql
sample=# CREATE OR REPLACE FUNCTION get_or_create_tag(tag_name tags.name%TYPE)
sample-# RETURNS SETOF tags AS $$
sample$# BEGIN
sample$#   RETURN QUERY INSERT INTO tags (name) VALUES (tag_name) RETURNING *;
sample$# EXCEPTION WHEN unique_violation THEN
sample$#   RETURN QUERY SELECT * FROM tags WHERE name = tag_name;
sample$# END;
sample$# $$ LANGUAGE plpgsql;
NOTICE:  型参照tags.name%TYPEはcharacter varyingに変換されました
CREATE FUNCTION
```

```Sql
sample=# TABLE tags;
 id | name
----+------
  1 | A
  2 | B
  3 | C
  4 | D
(4 行)


sample=# SELECT * FROM get_or_create_tag('E');
 id | name
----+------
  5 | E
(1 行)


sample=# SELECT * FROM get_or_create_tag('E');
 id | name
----+------
  5 | E
(1 行)
```

このアプローチの残念な欠点の 1 つは、すべての一意制約違反がログに記録されることです。データベース ログをざっと見る習慣がある場合、これは非常に煩わしい場合があります。
また、隠れた欠点があります。

### ユニーク制約違反の悪用

実験前のテーブルサイズを確認します

```Sql
sample=# SELECT pg_size_pretty(pg_relation_size('tags'));
 pg_size_pretty
----------------
 8192 bytes
(1 行)
```

非常に小さいです。次に、テーブルで「自動バキューム」を無効にし、すでに存在する 50K のタグを挿入します。

```Sql
sample=# ALTER TABLE tags SET (autovacuum_enabled = false);
ALTER TABLE
sample=# \timing on
タイミングは on です。
sample=#  SELECT get_or_create_tag('A') FROM generate_series(1, 50000);
 get_or_create_tag
-------------------
 (1,A)
 (1,A)
 (1,A)
 (1,A)
 ・・・
時間: 6116.945 ミリ秒(00:06.117)
```

テーブルにすでに存在する 50K 個のタグを挿入しようとすると、完了までに約 12 秒かかり、かなり遅いです。テーブルのサイズをもう一度確認します。

```Sql

sample=# SELECT pg_size_pretty(pg_relation_size('tags'));
pg_size_pretty
----------------
1776 kB
(1 行)
```

デッドタプルを確認すると先ほど`INSERT`失敗させた行が存在します。

```sql
sample=# SELECT relname, n_dead_tup, n_live_tup
sample-# FROM pg_stat_user_tables
sample-# WHERE relname = 'tags';
relname | n_dead_tup | n_live_tup
---------+------------+------------
tags    |      50002 |          4
(1 行)
```

`VACUUM'でデッドタプルを解放します。

```Sql
sample=# VACUUM tags;
VACUUM
sample=#  SELECT relname, n_dead_tup, n_live_tup
sample-# FROM pg_stat_user_tables
sample-# WHERE relname = 'tags';
 relname | n_dead_tup | n_live_tup
---------+------------+------------
 tags    |          0 |          5
```

テーブルサイズも元通り

```Sql
sample=# SELECT pg_size_pretty(pg_relation_size('tags'));
 pg_size_pretty
----------------
 8192 bytes
(1 行)
```

重複がほとんど発生しないプロセスでは、一意制約違反をキャッチして「取得または作成」機能を実装してもまったく問題ありません。ただし、重複が頻繁に発生するプロセスでは、肥大化によって大量のスペースが消費され、データベースに負担がかかる可能性があります。

この場合、不要な膨張を避けるには、まず最初に一意制約違反のトリガーを回避する必要があります。

タグがまだ存在しない場合にのみタグを作成するには、次のクエリを検討します

```Sql
sample=# INSERT INTO tags (name)
sample-#     SELECT name
sample-#     FROM (VALUES ('E'), ('F')) AS t(name)
sample-#     WHERE NOT EXISTS (
sample(#         SELECT 1
sample(#         FROM tags
sample(#         WHERE tags.name = t.name
sample(#     )
sample-# RETURNING *;
  id   | name
-------+------
 50010 | F
(1 行)


INSERT 0 1
```

タグ「E」は既にテーブルに存在するため、挿入は行われません。その結果、まだ存在していなかったタグ「F」のみが取得されます。

既存のタグと新しいタグの両方を取得するには、INSERT 句(別名、共通テーブル式、CTE)を実行し WITH、テーブルに対して新しいタグと既存のタグの両方をクエリします。

```sql
sample=# WITH new_tags AS (
sample(#     INSERT INTO tags (name)
sample(#     SELECT name
sample(#     FROM (VALUES ('F'), ('G')) AS t(name)
sample(#     WHERE NOT EXISTS (
sample(#         SELECT 1
sample(#         FROM tags
sample(#         WHERE tags.name = t.name
sample(#     )
sample(# )
sample-# SELECT *
sample-# FROM tags
sample-# WHERE name IN ('F', 'G');
  id   | name
-------+------
 50010 | F
(1 行)


sample=# TABLE tags;
  id   | name
-------+------
     1 | A
     2 | B
     3 | C
     4 | D
 50010 | F
 50008 | E
 50011 | G
(7 行)
```

タグ E は挿入されているのに取得できていません。  
何故ならデータ登録と取得が同一ステートメントのためです。

```sql
sample=# WITH
sample-# new_tags AS (
sample(#     INSERT INTO tags (name)
sample(#     SELECT name
sample(#     FROM (VALUES ('G'), ('H')) AS t(name)
sample(#     WHERE NOT EXISTS (
sample(#         SELECT 1
sample(#         FROM tags
sample(#         WHERE tags.name = t.name
sample(#     )
sample(#     RETURNING *
sample(# )
sample-# SELECT * FROM tags WHERE name IN ('G', 'H')
sample-# UNION ALL
sample-# SELECT * FROM new_tags;
  id   | name
-------+------
 50011 | G
 50012 | H
(2 行)
```

### 同時実行の問題を回避する

一意制約違反を防ぐことで肥大化を回避し、WITH を使用したターゲット テーブル自体の結果と句の結果を連結することで可視性の問題を回避してきました。  
しかし、このアプローチでも同時実行の問題が発生する可能性があります。

スクリプトファイルを用意します

```sql
-- get_or_create.sql
WITH
-- Generate a random amount of random tags
tags_to_insert AS (
    SELECT 'tag' || round(random() * 1000) AS name
    FROM generate_series(0, (random() * 10)::int)
),
-- From here on it's roughly the same...
new_tags AS (
    INSERT INTO tags (name)
        SELECT name
        FROM tags_to_insert t
        WHERE NOT EXISTS (
            SELECT 1
            FROM tags
            WHERE tags.name = t.name
        )
    RETURNING *
)
SELECT * FROM new_tags
UNION ALL
SELECT * FROM tags WHERE name IN (
    SELECT name
    FROM new_tags
);
```

複数コネクションから実行します

```sql
C:\Users\masami>pgbench -U postgres --client=4  --time=30  -f "C:\Users\masami\source\repos\get_or_create.sql" sample
Password:

pgbench (16.2)
starting vacuum...pgbench: error: ERROR:  繝ｪ繝ｬ繝ｼ繧ｷ繝ｧ繝ｳ"pgbench_branches"縺ｯ蟄伜惠縺励∪縺帙ｓ
pgbench: detail: (ignoring this error and continuing anyway)
pgbench: error: ERROR:  繝ｪ繝ｬ繝ｼ繧ｷ繝ｧ繝ｳ"pgbench_tellers"縺ｯ蟄伜惠縺励∪縺帙ｓ
pgbench: detail: (ignoring this error and continuing anyway)
pgbench: error: ERROR:  繝ｪ繝ｬ繝ｼ繧ｷ繝ｧ繝ｳ"pgbench_history"縺ｯ蟄伜惠縺励∪縺帙ｓ
pgbench: detail: (ignoring this error and continuing anyway)
end.
pgbench: error: client 3 script 0 aborted in command 0 query 0: ERROR:  驥崎､・＠縺溘く繝ｼ蛟､縺ｯ荳諢乗ｧ蛻ｶ邏・tags_name_unique"驕募渚縺ｨ縺ｪ繧翫∪縺・
DETAIL:  繧ｭ繝ｼ (name)=(tag39) 縺ｯ縺吶〒縺ｫ蟄伜惠縺励∪縺吶
pgbench: error: client 1 script 0 aborted in command 0 query 0: ERROR:  驥崎､・＠縺溘く繝ｼ蛟､縺ｯ荳諢乗ｧ蛻ｶ邏・tags_name_unique"驕募渚縺ｨ縺ｪ繧翫∪縺・
DETAIL:  繧ｭ繝ｼ (name)=(tag349) 縺ｯ縺吶〒縺ｫ蟄伜惠縺励∪縺吶・
pgbench: error: client 2 script 0 aborted in command 0 query 0: ERROR:  驥崎､・＠縺溘く繝ｼ蛟､縺ｯ荳諢乗ｧ蛻ｶ邏・tags_name_unique"驕募渚縺ｨ縺ｪ繧翫∪縺・
DETAIL:  繧ｭ繝ｼ (name)=(tag838) 縺ｯ縺吶〒縺ｫ蟄伜惠縺励∪縺吶・
pgbench: error: client 0 script 0 aborted in command 0 query 0: ERROR:  驥崎､・＠縺溘く繝ｼ蛟､縺ｯ荳諢乗ｧ蛻ｶ邏・tags_name_unique"驕募渚縺ｨ縺ｪ繧翫∪縺・
DETAIL:  繧ｭ繝ｼ (name)=(tag968) 縺ｯ縺吶〒縺ｫ蟄伜惠縺励∪縺吶・
transaction type: C:\Users\masami\source\repos\get_or_create.sql
scaling factor: 1
query mode: simple
number of clients: 4
number of threads: 1
maximum number of tries: 1
duration: 30 s
number of transactions actually processed: 104
number of failed transactions: 0 (0.000%)
latency average = 5.599 ms
initial connection time = 371.361 ms
tps = 714.477092 (without initial connection time)
pgbench: error: Run was aborted; the above results are incomplete.
```

どうやら、タグが存在しないことを確認してから実際にテーブルに挿入するまでのほんの数ミリ秒の間に、別のプロセスが同じ値を挿入し、ユニーク制約違反が発生した可能性があります。

ON CONFLICT 句を使うと UPSERT が実現できます。
たたし、この方法は変更した行のみを返します。

```sql
sample=# INSERT INTO tags (name) VALUES ('K'), ('L')
sample-# ON CONFLICT (name) DO NOTHING RETURNING *;
  id   | name
-------+------
 50492 | L
(1 行)
```

既に解決済みの方法が使えます。

```Sql
sample=# WITH
sample-# new_tags AS (
sample(#     INSERT INTO tags (name)
sample(#     VALUES ('B'), ('C')
sample(#     ON CONFLICT (name) DO NOTHING
sample(#     RETURNING *
sample(# )
sample-# SELECT * FROM tags WHERE name IN ('B', 'C')
sample-# UNION ALL
sample-# SELECT * FROM new_tags;
 id | name
----+------
  2 | B
  3 | C
(2 行)
```

これは期待どおりに動作し、べき等性を提供するという最初の目標を達成します、

```sqlsample=# \timing on
タイミングは on です。
sample=# WITH
sample-# new_tags AS (
sample(#     INSERT INTO tags (name)
sample(#     SELECT unnest(:'names'::text[])
sample(#     ON CONFLICT (name) DO NOTHING
sample(#     RETURNING *
sample(# )
sample-# SELECT * FROM tags WHERE name = ANY(:'names'::text[])
sample-# UNION ALL
sample-# SELECT * FROM new_tags;
 id | name
----+------
  1 | A
(1 行)


時間: 432.804 ミリ秒
```

データの状況

```Sql
時間: 432.804 ミリ秒
sample=# SELECT pg_size_pretty(pg_relation_size('tags'));
 pg_size_pretty
----------------
 32 kB
(1 行)


時間: 11.105 ミリ秒
sample=#  SELECT relname, n_dead_tup, n_live_tup
sample-# FROM pg_stat_user_tables
sample-# WHERE relname = 'tags';
 relname | n_dead_tup | n_live_tup
---------+------------+------------
 tags    |          8 |        472
(1 行)
```

最後に、プロセスが多くのユーザーによって同時に実行された場合でも安全かどうかを確認するために、ランダムな量のランダムなタグをテーブルに挿入するスクリプトを準備します。

```Sql
-- get_or_create_on_conflict.sql
WITH
-- Generate a random amount of random tags
tags_to_insert AS (
    SELECT 'tag' || round(random() * 1000) AS name
    FROM generate_series(0, (random() * 10)::int)
),
-- From here on it's roughly the same...
new_tags AS (
    INSERT INTO tags (name)
      SELECT name FROM tags_to_insert
    ON CONFLICT DO NOTHING
    RETURNING *
)
SELECT * FROM new_tags
UNION ALL
SELECT * FROM tags WHERE name IN (SELECT name FROM tags_to_insert);
```

### 間違った方法

```Sql
sample=# INSERT INTO tags (name) VALUES ('B'), ('C')
sample-# ON CONFLICT (name) DO UPDATE SET id = EXCLUDED.id
sample-# RETURNING *;
   id   | name
--------+------
 500992 | B
 500993 | C
(2 行)
```

既存のタグに遭遇すると、ID を現在の値に更新します。
目的は達成していますが、更新するためデータが誇大化します。

実験してみます。

```Sql
sample=# truncate tags;
TRUNCATE TABLE
時間: 68.604 ミリ秒
sample=# SELECT * FROM get_or_create_tag('A');
   id   | name
--------+------
 600994 | A
(1 行)


時間: 3.611 ミリ秒
sample=# SELECT * FROM get_or_create_tag('B');
   id   | name
--------+------
 600995 | B
(1 行)


時間: 1.001 ミリ秒
sample=# SELECT * FROM get_or_create_tag('C');
   id   | name
--------+------
 600996 | C
(1 行)


時間: 0.872 ミリ秒
sample=# SELECT * FROM get_or_create_tag('D');
   id   | name
--------+------
 600997 | D
(1 行)


sample=# SELECT
sample-#     pg_size_pretty(pg_relation_size('tags')) table_size,
sample-#     pg_size_pretty(pg_total_relation_size('tags') - pg_relation_size('tags')) indexes_size;
 table_size | indexes_size
------------+--------------
 8192 bytes | 32 kB
(1 行)

sample=# DO $$
sample$# BEGIN
sample$#     FOR i in 1..50000 loop
sample$#         INSERT INTO tags (name) VALUES ('C'), ('D')
sample$#         ON CONFLICT (name)
sample$#         DO UPDATE SET name = EXCLUDED.name;
sample$#     END LOOP;
sample$# END $$;
DO
時間: 94588.398 ミリ秒(01:34.588)

sample=# table tags;
   id   | name
--------+------
 600994 | A
 600995 | B
 600996 | C
 600997 | D
(4 行)

sample=# SELECT
sample-#     pg_size_pretty(pg_relation_size('tags')) table_size,
sample-#     pg_size_pretty(pg_total_relation_size('tags') - pg_relation_size('tags')) indexes_size;
 table_size | indexes_size
------------+--------------
 3544 kB    | 56 kB
(1 行)
```

テーブルのサイズは 50 倍ほど大きくなり、インデックスは 2 倍になりました。この肥大化を解消するには、テーブルをバキュームしてインデックスを再作成する必要があります。

```sql
sample=# VACUUM FULL tags;
VACUUM
時間: 49.174 ミリ秒
sample=#  REINDEX TABLE tags;
REINDEX
時間: 11.459 ミリ秒
sample=# SELECT
sample-#     pg_size_pretty(pg_relation_size('tags')) table_size,
sample-#     pg_size_pretty(pg_total_relation_size('tags') - pg_relation_size('tags')) indexes_size;
 table_size | indexes_size
------------+--------------
 8192 bytes | 32 kB
(1 行)
```

### スキーマの変更を避ける

`INSERT ON CONFLICT`は非常に強力なコマンドですが、言及する価値のある制限が 1 つあります。行を一致させるには、`INSERT ON CONFLICT`ターゲット テーブルに、一致する列に対する一意制約または排他制約のいずれかが必要です。

```sql
sample=# ALTER TABLE tags DROP CONSTRAINT  tags_name_unique;
ALTER TABLE
時間: 13.394 ミリ秒
sample=# INSERT INTO tags (name) VALUES ('B'), ('C') ON CONFLICT (name) DO NOTHING;
ERROR:  ON CONFLICT 指定に合致するユニーク制約または排除制約がありません
時間: 13.952 ミリ秒
```

一意の制約がない、または制約が使用できない場合があります。排他制約は、複雑な条件に制約を適用する場合に便利ですが、制約を適用するためにインデックスを維持する必要があるという独自のコストも伴います。

PostgreSQL 15 以降では、データを同期するための別のオプションである `MERGEINSERT ON CONFLICT`ステートメントが追加されました。

```sql
sample=# MERGE INTO tags USING (VALUES
sample(#     ('A', false),
sample(#     ('B', true),
sample(#     ('C', false),
sample(#     ('D', true)
sample(# ) AS t(name, deleted)
sample-#     ON t.name = tags.name
sample-#     WHEN MATCHED AND deleted THEN DELETE
sample-#     WHEN MATCHED AND NOT deleted THEN DO NOTHING
sample-#     WHEN NOT MATCHED AND deleted THEN DO NOTHING
sample-#     WHEN NOT MATCHED AND NOT deleted THEN INSERT (name) VALUES (t.name);
MERGE 2
時間: 25.191 ミリ秒

sample=# TABLE tags;
   id   | name
--------+------
 600994 | A
 600996 | C
(2 行)

```

`MERGE`は`INSERT ON CONFLIC`のような制約がありません。

しかし、残念ながら、PostgreSQL 16 の時点では`MERGE`に`RETURNING`句が含まれていないため、`WITH`句で`RETURNING`を使用することができません。この状況は PostgreSQL 17 で変わる予定です。PostgreSQL 17 では`MERGE`文が`RETURNING`句をサポートするようになります。

PostgreSQL17 の場合、次のやり方がベストです。(16 で実施しているのでエラー)

```sql
sample=# WITH
sample-# new_tags AS (
sample(#   MERGE INTO tags
sample(#   USING (VALUES ('B'), ('C')) AS t(name)
sample(#   ON tags.name = t.name
sample(#   WHEN NOT MATCHED THEN INSERT (name) VALUES (t.name)
sample(#   RETURNING *
sample(# )
sample-# SELECT * FROM tags WHERE name IN ('B', 'C')
sample-# UNION ALL
sample-# SELECT * FROM new_tags;
ERROR:  "RETURNING"またはその近辺で構文エラー
行 7:   RETURNING *
        ^
時間: 4.673 ミリ秒
```
